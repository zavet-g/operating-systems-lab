# Контрольная работа по дисциплине "Операционные системы"

**Студент:** Зачетная книжка № 2110-ПИб-6440
**Вариант:** 29

## Вычисление варианта

```
S = 2 + 1 + 1 + 0 + 6 + 4 + 4 + 0 = 18
НОМЕР_ВАРИАНТА = (18 mod 4) × 10 + (18 mod 10) + 1
НОМЕР_ВАРИАНТА = 2 × 10 + 8 + 1 = 29
```

## Часть 1: Теоретическая

**Вопрос (вариант 29):** Сегментно-страничная организация памяти. Преимущества и недостатки данного способа.

### Ответ:

**Сегментно-страничная организация памяти** — это комбинированный метод управления памятью, который объединяет преимущества сегментной и страничной организации.

#### Принцип работы:

1. Адресное пространство процесса делится на логические сегменты (код, данные, стек)
2. Каждый сегмент, в свою очередь, делится на страницы фиксированного размера
3. Виртуальный адрес состоит из трёх частей: номер сегмента, номер страницы внутри сегмента, смещение внутри страницы
4. Трансляция адреса происходит в два этапа:
   - По номеру сегмента находится таблица страниц этого сегмента
   - По номеру страницы в этой таблице находится физический адрес страницы
   - К физическому адресу страницы добавляется смещение

#### Преимущества:

1. **Логическая организация памяти** — поддерживается логическое деление программы на сегменты (код, данные, стек), что упрощает разработку и отладку
2. **Эффективное использование памяти** — страничная организация внутри сегментов позволяет избежать внешней фрагментации
3. **Разделение и защита** — различные сегменты могут иметь разные права доступа (execute, read, write)
4. **Разделяемые сегменты** — несколько процессов могут разделять один сегмент (например, библиотеки кода)
5. **Динамический рост сегментов** — сегменты могут увеличиваться независимо друг от друга
6. **Минимизация внутренней фрагментации** — благодаря страничной организации внутри сегментов

#### Недостатки:

1. **Сложность реализации** — требуется более сложное аппаратное обеспечение для двухуровневой трансляции адресов
2. **Увеличенное время трансляции** — два обращения к таблицам (таблица сегментов и таблица страниц)
3. **Увеличенный объём служебной информации** — необходимо хранить как таблицу сегментов, так и таблицы страниц для каждого сегмента
4. **Остаётся внутренняя фрагментация** — последняя страница каждого сегмента может быть заполнена не полностью
5. **Сложность управления** — операционная система должна управлять как сегментами, так и страницами

#### Примеры использования:

- Intel x86 архитектура (в защищённом режиме) использует сегментно-страничную организацию
- Некоторые версии UNIX

## Часть 2: Практическая

### Задание А: Генеалогическое дерево процессов (вариант 29)

Необходимо создать следующее дерево процессов:

```
ОРАНЖЕВЫЙ (root)
  ├── ЖЕЛТЫЙ
  │     ├── ЗЕЛЕНЫЙ
  │     └── ГОЛУБОЙ
  ├── ГОЛУБОЙ
  └── ГОЛУБОЙ
```

### Задание Б: Дополнительные действия процессов (вариант 5, 8, 13, 21, 29, 37, 39)

**Жёлтый процесс:**
1. Получает со стандартного потока ввода список всех активных процессов
2. Выводит на экран процессы только с **чётными PID**
3. Передаёт при помощи **семафоров** оранжевому каждый из этих номеров (никаких дополнительных средств коммуникации не использовать, только семафоры)
4. При помощи **pipe** передаёт имена чётных процессов зелёному

**Оранжевый процесс:**
- Получает PID через семафоры
- Суммирует и выводит каждый раз полученное значение и текущую сумму на экран

**Зелёный процесс:**
- Получает имена процессов через pipe от жёлтого
- Записывает их в файл

**Голубые процессы:**
- Выводят информацию о своём PID и PPID

## Компиляция и запуск

### Компиляция:

```bash
make
```

### Запуск:

```bash
# Вариант 1: Передать список процессов через pipe
ps -e | ./variant29

# Вариант 2: Использовать make для запуска
make test

# Вариант 3: Запуск с ограниченным списком процессов
ps -e | head -20 | ./variant29
```

### Очистка:

```bash
make clean
```

## Используемые системные вызовы и функции

1. **Управление процессами:**
   - `fork()` - создание дочерних процессов
   - `getpid()`, `getppid()` - получение PID и PPID
   - `wait()` - ожидание завершения дочерних процессов
   - `exit()` - завершение процесса

2. **Межпроцессное взаимодействие:**
   - **Семафоры POSIX:**
     - `sem_open()` - создание/открытие именованного семафора
     - `sem_wait()` - операция P (захват семафора)
     - `sem_post()` - операция V (освобождение семафора)
     - `sem_close()` - закрытие семафора
     - `sem_unlink()` - удаление именованного семафора
   - **Pipe (неименованные каналы):**
     - `pipe()` - создание канала
     - `read()`, `write()` - чтение/запись в канал

3. **Работа с файлами:**
   - `open()` - открытие файла
   - `write()` - запись в файл
   - `close()` - закрытие файла

## Результаты работы

После выполнения программы:

1. **На экране** отображается:
   - Информация о запуске и завершении каждого процесса с указанием PID и PPID
   - Список процессов с чётными PID (выводит ЖЁЛТЫЙ)
   - Получаемые PID и текущая сумма (выводит ОРАНЖЕВЫЙ)

2. **В файле `even_processes.txt`** сохраняются:
   - Имена всех процессов с чётными PID

## Структура файлов проекта

```
variant29/
  ├── main.c                    # Исходный код программы
  ├── Makefile                  # Файл сборки
  ├── README.md                 # Данный файл
  ├── even_processes.txt        # Результат работы (создаётся при выполнении)
  └── variant29                 # Исполняемый файл (создаётся при компиляции)
```

## Особенности реализации

1. **Семафоры** используются для синхронизации передачи PID от жёлтого к оранжевому процессу
2. **Pipe** используется для передачи имён процессов от жёлтого к зелёному
3. Программа корректно обрабатывает ввод от команды `ps -e`
4. Все процессы выводят информацию о своём PID и PPID для построения генеалогического дерева
5. Используются именованные POSIX-семафоры для межпроцессного взаимодействия

## Тестирование

Программа протестирована на:
- macOS (Darwin kernel)
- Входные данные: вывод команды `ps -e`

Проверено:
- ✓ Корректное создание генеалогического дерева процессов
- ✓ Фильтрация процессов с чётными PID
- ✓ Передача данных через семафоры (оранжевый получает и суммирует PID)
- ✓ Передача данных через pipe (зелёный записывает в файл)
- ✓ Вывод информации о PID и PPID каждого процесса
